<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Sistema de Colas Din√°mico - Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.95;
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .feature-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status-bar {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 25px;
            position: relative;
            overflow: hidden;
        }

        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .status-item {
            text-align: center;
            padding: 15px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .status-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.8);
        }

        .status-value {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            display: block;
        }

        .status-label {
            color: #555;
            font-size: 1rem;
            font-weight: 600;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 5px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.92) 100%);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2, #667eea);
            background-size: 200% 100%;
            animation: cardBorder 3s ease infinite;
        }

        @keyframes cardBorder {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        }

        .card.full-width {
            grid-column: 1 / -1;
        }

        .card h3 {
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 20px;
            font-size: 1.4rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .queues-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .queue-card {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .queue-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .queue-card.critical {
            border-color: #dc3545;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .queue-card.high {
            border-color: #fd7e14;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }

        .queue-card.normal {
            border-color: #28a745;
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .queue-card.bulk {
            border-color: #6c757d;
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
        }

        .queue-card.dynamic {
            border-color: #6f42c1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .queue-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .queue-type {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
            background: rgba(255,255,255,0.3);
        }

        .queue-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .workers-container {
            margin-top: 15px;
        }

        .workers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .worker-card {
            background: #4CAF50;
            color: white;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .worker-card.idle {
            background: #9E9E9E;
        }

        .worker-card.active {
            background: #2196F3;
            animation: pulse 2s infinite;
        }

        .worker-card.busy {
            background: #FF9800;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .control-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .input-group input, .input-group select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .events-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .event-item {
            padding: 10px;
            border-left: 4px solid;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 0 8px 8px 0;
        }

        .event-item.task_created {
            border-color: #28a745;
        }

        .event-item.task_started {
            border-color: #007bff;
        }

        .event-item.task_completed {
            border-color: #17a2b8;
        }

        .event-item.task_failed {
            border-color: #dc3545;
        }

        .event-item.queue_stats {
            border-color: #6f42c1;
        }

        .event-time {
            font-size: 0.8rem;
            color: #666;
            float: right;
        }

        .event-type {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .task-queue {
            max-height: 300px;
            overflow-y: auto;
        }

        .task-item {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-item.processing {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .task-item.completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .task-item.failed {
            background: #ffebee;
            border-color: #f44336;
        }

        .task-priority {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn.success {
            background: linear-gradient(135deg, #28a745, #20c997);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .btn.success:hover {
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.6);
        }

        .btn.danger {
            background: linear-gradient(135deg, #dc3545, #e74c3c);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .btn.danger:hover {
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.6);
        }

        .btn.warning {
            background: linear-gradient(135deg, #ffc107, #ff9800);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
        }

        .btn.warning:hover {
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.6);
        }



        /* Estilos para colas din√°micas */
        .queue-placeholder {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            border: 2px dashed #ddd;
        }

        .queue-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
            min-height: 200px;
        }

        .queue-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .queue-header h4 {
            margin: 0;
            color: #333;
            font-size: 1.2rem;
        }

        .queue-status {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .queue-status.active {
            background: #28a745;
            color: white;
        }

        .queue-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }

        .queue-priority {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            padding: 8px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .queue-activity {
            text-align: center;
            font-size: 0.8rem;
            color: #999;
            font-style: italic;
        }

        /* Estilos para eventos */
        .event-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            border-left: 4px solid #ddd;
        }

        .event-item.success {
            background: #e8f5e8;
            border-left-color: #4caf50;
        }

        .event-item.error {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .event-item.sistema {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .event-content {
            flex: 1;
        }

        .event-time {
            color: #666;
            font-size: 0.8rem;
        }

        /* Estilos para tareas */
        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            border: 1px solid #eee;
            background: #f9f9f9;
        }

        .task-item.completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .task-item.failed {
            background: #ffebee;
            border-color: #f44336;
        }

        .task-item.processing {
            background: #fff3e0;
            border-color: #ff9800;
        }



        .connection-status {
            position: fixed;
            top: 25px;
            right: 25px;
            padding: 12px 20px;
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            animation: connectionPulse 2s infinite;
        }

        @keyframes connectionPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .connection-status.connected {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .connection-status.disconnected {
            background: linear-gradient(135deg, #dc3545, #e74c3c);
        }

        .stats-chart {
            height: 200px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            margin-top: 10px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .status-bar {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <div class="connection-status" id="connectionStatus">
        üî¥ Desconectado
    </div>

    <div class="container">
        <div class="header">
            <h1>üöÄ Sistema de Colas Din√°mico - SIN L√çMITES</h1>
            <div class="subtitle">
                <span class="feature-badge">‚ú® Escalado Ilimitado</span>
                <span class="feature-badge">üóëÔ∏è Eliminaci√≥n Universal</span>
                <span class="feature-badge">ü§ñ Creaci√≥n Autom√°tica</span>
                <span class="feature-badge">üìà Monitoreo en Tiempo Real</span>
            </div>
        </div>

        <div class="status-bar" id="statusBar">
            <div class="status-item">
                <span class="status-value" id="systemType">Dynamic</span>
                <div class="status-label">Tipo de Sistema</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="totalWorkers">0</span>
                <div class="status-label">Workers Totales</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="totalQueues">0</span>
                <div class="status-label">Colas Activas</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="pendingTasks">0</span>
                <div class="status-label">Tareas Pendientes</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="processingTasks">0</span>
                <div class="status-label">En Proceso</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="completedTasks">0</span>
                <div class="status-label">Completadas</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="failedTasks">0</span>
                <div class="status-label">Fallidas</div>
            </div>
            <div class="status-item">
                <span class="status-value" id="scalingEvents">0</span>
                <div class="status-label">Escalados</div>
            </div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <button class="btn btn-primary" onclick="toggleAutoRefresh()">
                    <span id="autoRefreshText">üîÑ Auto Refresh ON</span>
                </button>
                <button class="btn btn-success" onclick="refreshData()">üîÉ Actualizar</button>
            </div>
            
            <div class="control-group">
                <label>Escalar Cola:</label>
                <div class="input-group">
                    <select id="queueSelect">
                        <option value="">Seleccionar cola...</option>
                    </select>
                    <input type="number" id="workerCount" placeholder="Workers" min="0" max="100" style="width: 80px;">
                    <button class="btn btn-warning" onclick="scaleQueue()">‚ö° Escalar</button>
                </div>
            </div>

            <div class="control-group">

                <button class="btn primary" onclick="showBulkCreateModal()">üì¶ Crear Colas Especializadas</button>
                <button class="btn danger" onclick="clearAllQueues()">üóëÔ∏è Eliminar Colas</button>
                <button class="btn danger" onclick="clearAllTasks()">üßπ Limpiar Tareas</button>
                <button class="btn danger" onclick="clearEvents()">ÔøΩ Limpiar Log</button>
            </div>
            
            <!-- Modal para creaci√≥n masiva -->
            <div id="bulkCreateModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">
                    <h3 style="color: #667eea; margin-bottom: 20px;">üöÄ Crear Colas Especializadas</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Cantidad de colas:</label>
                        <input type="number" id="bulkQueueCount" min="1" max="50" value="5" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                        <small style="color: #666; margin-top: 5px; display: block;">üí° M√∫ltiples colas pueden compartir rangos de prioridad para mejor balanceo</small>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Workers por cola:</label>
                        <input type="number" id="bulkWorkerCount" min="1" max="100" value="3" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Prefijo del nombre:</label>
                        <input type="text" id="bulkQueuePrefix" value="cola_" placeholder="cola_" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="btn" onclick="closeBulkCreateModal()" style="background: #6c757d;">Cancelar</button>
                        <button class="btn primary" onclick="createBulkQueues()">üöÄ Crear Colas</button>
                    </div>
                </div>
            </div>
        </div>





        <!-- Colas Din√°micas -->
        <div class="card full-width">
            <h3>üîÑ Colas del Sistema</h3>
            <div class="queues-grid" id="queuesContainer">
                <div class="queue-placeholder">
                    <p>üîÑ Cargando colas del sistema...</p>
                    <small>Las colas aparecer√°n aqu√≠ cuando se carguen los datos</small>
                </div>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="card">
                <h3>ÔøΩ Tareas Recientes</h3>
                <div class="task-queue" id="taskQueue">
                    <div class="task-item">
                        <div>
                            <strong>Cargando...</strong><br>
                            <small>Obteniendo datos del sistema</small>
                        </div>
                        <span class="task-priority">-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ÔøΩ M√©tricas por Prioridad</h3>
                <div id="priorityStats">
                    <div style="text-align: center; color: #666;">
                        Cargando estad√≠sticas...
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üìù Log de Eventos</h3>
                <div class="events-container" id="eventsContainer">
                    <div class="event-item queue_stats">
                        <div class="event-time">Sistema</div>
                        <div class="event-type">Info</div>
                        <div>Iniciando dashboard din√°mico...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const ACCESS_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTg5MjQ2NDAsInN1YiI6IlZJQzAwMSJ9.6s2ah2WMT39BhUbVOXgN2AVJp05L1Q7bZDeCaFXn-xc";

        class DynamicQueueDashboard {
            constructor() {
                this.apiBaseUrl = 'http://localhost:8000/queue';
                this.autoRefresh = true;
                this.refreshInterval = 3000; // 3 segundos
                this.maxEvents = 50;
                this.refreshTimer = null;
                this.queuesData = {};

                this.init();
            }

            async init() {
                console.log('üöÄ Iniciando Dashboard Din√°mico...');
                await this.checkConnection();
                await this.loadInitialData();
                this.startAutoRefresh();
                this.addEvent('Sistema', 'Dashboard iniciado correctamente', 'success');
            }

            async checkConnection() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/status`, {
                        headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                    });

                    if (response.ok) {
                        this.updateConnectionStatus(true);
                        console.log('‚úÖ Conexi√≥n establecida con sistema din√°mico');
                        return true;
                    } else {
                        throw new Error('Error de conexi√≥n');
                    }
                } catch (error) {
                    this.updateConnectionStatus(false);
                    console.error('‚ùå Error de conexi√≥n:', error);
                    return false;
                }
            }

            async loadInitialData() {
                await Promise.all([
                    this.updateSystemStats(),
                    this.updateQueuesData(),
                    this.updateTasksList(),
                    this.updatePriorityStats()
                ]);
            }

            updateConnectionStatus(connected) {
                const status = document.getElementById('connectionStatus');
                if (connected) {
                    status.textContent = 'üü¢ Conectado';
                    status.className = 'connection-status connected';
                } else {
                    status.textContent = 'üî¥ Desconectado';
                    status.className = 'connection-status disconnected';
                }
            }

            async updateSystemStats() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/status`, {
                        headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                    });
                    if (!response.ok) throw new Error('Error fetching stats');

                    const stats = await response.json();
                    this.updateStatusBar(stats);

                } catch (error) {
                    console.error('Error actualizando estad√≠sticas:', error);
                }
            }

            async updateQueuesData() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/queues/all`, {
                        headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                    });
                    if (!response.ok) throw new Error('Error fetching queues');

                    const data = await response.json();
                    this.queuesData = data;
                    this.updateQueuesGrid(data);
                    this.updateQueueSelect(data);

                } catch (error) {
                    console.error('Error actualizando colas:', error);
                }
            }

            async updateTasksList() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/tasks?page_size=10`, {
                        headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                    });
                    if (!response.ok) throw new Error('Error fetching tasks');

                    const data = await response.json();
                    this.updateTasksQueue(data.data || []);

                } catch (error) {
                    console.error('Error actualizando tareas:', error);
                }
            }

            async updatePriorityStats() {
                try {
                    const response = await fetch(`${this.apiBaseUrl}/status`, {
                        headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                    });
                    if (!response.ok) throw new Error('Error fetching priority stats');

                    const data = await response.json();
                    this.updatePriorityStatsDisplay(data.priority_counts || {});

                } catch (error) {
                    console.error('Error actualizando estad√≠sticas de prioridad:', error);
                }
            }

            updateStatusBar(stats) {
                document.getElementById('systemType').textContent = stats.system_type || 'Dynamic';
                document.getElementById('totalWorkers').textContent = stats.total_workers || 0;
                document.getElementById('totalQueues').textContent = stats.total_queues || 0;

                const taskCounts = stats.task_counts || {};
                document.getElementById('pendingTasks').textContent = taskCounts.pending || 0;
                document.getElementById('processingTasks').textContent = taskCounts.processing || 0;
                document.getElementById('completedTasks').textContent = taskCounts.completed || 0;
                document.getElementById('scalingEvents').textContent = stats.dynamic_scaling_events || 0;
            }

            updateQueuesGrid(data) {
                const grid = document.getElementById('queuesGrid');
                if (!data.success) return;

                const allQueues = { ...data.predefined_queues, ...data.dynamic_queues };
                
                grid.innerHTML = Object.keys(allQueues).map(queueKey => {
                    const queue = allQueues[queueKey];
                    const config = queue.config;
                    const queueClass = this.getQueueClass(queueKey, queue.is_predefined);
                    
                    return `
                        <div class="queue-card ${queueClass}">
                            <div class="queue-header">
                                <div class="queue-name">${config.name}</div>
                                <div class="queue-type">${queue.is_predefined ? 'Predefinida' : 'Din√°mica'}</div>
                            </div>
                            <div class="queue-stats">
                                <div class="stat-item">
                                    <span class="stat-value">${queue.active_workers || 0}</span>
                                    <div class="stat-label">Workers</div>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value">${queue.pending_tasks || 0}</span>
                                    <div class="stat-label">Pendientes</div>
                                </div>
                            </div>
                            <div class="workers-container">
                                <small>Prioridades: ${config.priority_range.join('-')} | Max: ${config.max_workers}</small>
                                <div class="workers-grid">
                                    ${this.generateWorkerCards(queue.workers || [])}
                                </div>
                            </div>
                            ${!queue.is_predefined ? `
                                <button class="btn btn-danger" style="width:100%; margin-top:10px; font-size:0.8rem;" 
                                        onclick="removeQueue('${queueKey}')">
                                    üóëÔ∏è Eliminar
                                </button>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }

            getQueueClass(queueKey, isPredefined) {
                if (!isPredefined) return 'dynamic';
                
                const classMap = {
                    '1': 'critical',
                    '2': 'high', 
                    '3': 'normal',
                    '4': 'bulk'
                };
                return classMap[queueKey] || 'normal';
            }

            generateWorkerCards(workers) {
                if (!workers.length) return '<div class="worker-card idle">Sin workers</div>';
                
                return workers.map(workerId => 
                    `<div class="worker-card active">${workerId.split('_').pop()}</div>`
                ).join('');
            }

            updateTasksQueue(tasks) {
                const queue = document.getElementById('taskQueue');
                
                if (!tasks.length) {
                    queue.innerHTML = '<div style="text-align:center; color:#666; padding:20px;">No hay tareas recientes</div>';
                    return;
                }

                queue.innerHTML = tasks.slice(0, 10).map(task => `
                    <div class="task-item ${task.status}">
                        <div>
                            <strong>${task.task_type}</strong><br>
                            <small>${new Date(task.created_at).toLocaleString()}</small>
                        </div>
                        <span class="task-priority">P${task.priority}</span>
                    </div>
                `).join('');
            }

            updatePriorityStatsDisplay(priorityCounts) {
                const container = document.getElementById('priorityStats');
                
                if (!Object.keys(priorityCounts).length) {
                    container.innerHTML = '<div style="text-align:center; color:#666;">No hay tareas pendientes</div>';
                    return;
                }

                container.innerHTML = Object.entries(priorityCounts)
                    .sort(([a], [b]) => parseInt(a) - parseInt(b))
                    .map(([priority, count]) => `
                        <div style="display:flex; justify-content:space-between; padding:5px 0; border-bottom:1px solid #eee;">
                            <span>Prioridad ${priority}:</span>
                            <strong>${count} tareas</strong>
                        </div>
                    `).join('');
            }

            updateQueueSelect(data) {
                const select = document.getElementById('queueSelect');
                const allQueues = { ...data.predefined_queues, ...data.dynamic_queues };
                
                select.innerHTML = '<option value="">Seleccionar cola...</option>' +
                    Object.keys(allQueues).map(queueKey => {
                        const queue = allQueues[queueKey];
                        return `<option value="${queue.config.name}">${queue.config.name} (${queue.active_workers || 0}/${queue.config.max_workers})</option>`;
                    }).join('');
            }


            updateStatusBar(stats) {
                document.getElementById('totalWorkers').textContent = stats.total_workers || 0;
                document.getElementById('activeWorkers').textContent = stats.active_workers || 0;

                const taskCounts = stats.task_counts || {};
                document.getElementById('pendingTasks').textContent = taskCounts.pending || 0;
                document.getElementById('processingTasks').textContent = taskCounts.processing || 0;
                document.getElementById('completedTasks').textContent = taskCounts.completed || 0;
                document.getElementById('failedTasks').textContent = taskCounts.failed || 0;
            }

            updateWorkersGrid(workers) {
                const grid = document.getElementById('workersGrid');

                if (!workers || workers.length === 0) {
                    grid.innerHTML = '<div class="worker-card idle"><div>Sin workers activos</div></div>';
                    return;
                }

                grid.innerHTML = workers.map(worker => `
                <div class="worker-card ${worker.status}">
                    <div><strong>${worker.id}</strong></div>
                    <small>${worker.status === 'active' ? `Tareas: ${worker.tasks_processed}` : 'Inactivo'}</small>
                    <div style="font-size: 0.7rem; margin-top: 5px; opacity: 0.7;">
                        Uptime: ${Math.floor(worker.uptime)}s
                    </div>
                </div>
            `).join('');
            }

            updateTaskQueue(tasks) {
                const queue = document.getElementById('taskQueue');

                if (!tasks || tasks.length === 0) {
                    queue.innerHTML = `
            <div class="task-item" style="text-align:center; width:100%;">
                <strong>No hay tareas en cola</strong>
            </div>
        `;
                    return;
                }

                queue.innerHTML = tasks.map(task => `
        <div class="task-item ${task.status}">
            <div>
                <strong>${task.task_id.substring(0, 8)}...</strong><br>
                <small>${task.task_type}</small>
            </div>
            <div>
                <div class="task-priority">${task.priority}</div>
                <small style="display: block; margin-top: 5px;">
                    ${task.status === "pending" ? "‚è≥ Pendiente" :
                        task.status === "processing" ? "‚öôÔ∏è Procesando" :
                            task.status === "completed" ? "‚úÖ Completada" :
                                task.status === "failed" ? "‚ùå Fallida" :
                                    task.status === "cancelled" ? "üö´ Cancelada" : task.status}
                </small>
            </div>
        </div>
    `).join('');
            }

            updatePerformanceChart(stats) {
                const chart = document.getElementById('performanceChart');

                // Usar los datos reales de task_counts en lugar de stats
                const tasksCompleted = stats.task_counts?.completed || 0;
                const tasksFailed = stats.task_counts?.failed || 0;
                const totalTasks = stats.total_tasks || 0;

                // Calcular el porcentaje basado en tareas completadas vs total de tareas procesadas (completadas + fallidas)
                const processedTasks = tasksCompleted + tasksFailed;
                const successRate = processedTasks > 0 ? (tasksCompleted / processedTasks * 100).toFixed(1) : 0;

                chart.innerHTML = `
                <div style="text-align: center; width: 100%;">
                    <div style="font-size: 2rem; font-weight: bold; color: #667eea; margin-bottom: 10px;">
                        ${successRate}%
                    </div>
                    <div style="color: #666; margin-bottom: 15px;">Tasa de √âxito</div>
                    <div style="background: #e0e0e0; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #28a745, #17a2b8); height: 100%; width: ${successRate}%; transition: width 0.5s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.9rem; color: #666;">
                        <span>Completadas: ${tasksCompleted}</span>
                        <span>Fallidas: ${tasksFailed}</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 0.8rem; color: #888;">
                        Total procesadas: ${processedTasks} de ${totalTasks}
                    </div>
                </div>
            `;
            }

            setupEventStream() {
                try {
                    // Deshabilitar EventSource por ahora y usar solo polling
                    console.log('üìä Usando polling en lugar de EventSource');
                    this.setupPollingFallback();

                } catch (error) {
                    console.error('Error configurando EventSource:', error);
                    this.setupPollingFallback();
                }
            }

            setupPollingFallback() {
                console.log('üì° Usando polling como fallback...');
                let lastTaskCount = 0;

                setInterval(async () => {
                    try {
                        const response = await fetch(`${this.apiBaseUrl1}/queue/status`, {
                            headers: { "Authorization": `Bearer ${ACCESS_TOKEN}` }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            const currentTaskCount = data.total_tasks;

                            // Simular eventos cuando cambie el n√∫mero de tareas
                            if (currentTaskCount > lastTaskCount) {
                                this.addEvent({
                                    event_type: 'task_created',
                                    message: `Nueva tarea creada (Total: ${currentTaskCount})`,
                                    timestamp: new Date().toISOString(),
                                    data: { total_tasks: currentTaskCount }
                                }, true);
                            }

                            lastTaskCount = currentTaskCount;
                        }
                    } catch (error) {
                        console.error('Error en polling:', error);
                    }
                }, 3000);
            }


            addEvent(eventData, animate = true) {
                const container = document.getElementById('eventsContainer');

                const eventDiv = document.createElement('div');
                eventDiv.className = `event-item ${eventData.event_type}`;

                if (animate) {
                    eventDiv.style.transform = 'translateX(-100%)';
                    eventDiv.style.transition = 'transform 0.3s ease-out';
                }

                const time = new Date(eventData.timestamp).toLocaleTimeString();
                const taskInfo = eventData.task_id ? `<br><small>Task: ${eventData.task_id.substring(0, 8)}...</small>` : '';

                eventDiv.innerHTML = `
                    <div class="event-time">${time}</div>
                    <div class="event-type">${eventData.event_type.replace('_', ' ')}</div>
                    <div>
                        ${this.formatEventMessage(eventData)}
                        ${taskInfo}
                    </div>
                `;

                container.insertBefore(eventDiv, container.firstChild);

                if (animate) {
                    setTimeout(() => {
                        eventDiv.style.transform = 'translateX(0)';
                    }, 10);
                }

                // Limitar n√∫mero de eventos mostrados
                while (container.children.length > this.maxEvents) {
                    container.removeChild(container.lastChild);
                }
            }

            formatEventMessage(eventData) {
                switch (eventData.event_type) {
                    case 'task_created':
                        // Si tiene message personalizado, usarlo directamente
                        if (eventData.message && eventData.message.includes('Nueva tarea creada (Total:')) {
                            return eventData.message;
                        }
                        // Si no, usar task_type
                        const taskType = eventData.task_type || eventData.data?.task_type || 'desconocido';
                        return `Nueva tarea creada: ${taskType}`;
                    case 'task_started':
                        return `Tarea iniciada por ${eventData.worker_id || 'worker'}`;
                    case 'task_completed':
                        return `Tarea completada exitosamente`;
                    case 'task_failed':
                        return `Tarea fall√≥: ${eventData.data?.error || 'Error desconocido'}`;
                    case 'queue_stats':
                        return `Estad√≠sticas actualizadas - ${eventData.data?.task_counts?.pending || 0} pendientes`;
                    default:
                        return eventData.message || `Evento: ${eventData.event_type || 'desconocido'}`;
                        return `Evento: ${eventData.event_type}`;
                }
            }

            startAutoRefresh() {
                if (this.autoRefresh) {
                    // Refrescar stats y workers cada 2s
                    this.statsTimer = setInterval(() => {
                        this.fetchStats();
                        this.fetchWorkers();
                    }, 2000);

                    // Refrescar cola de tareas cada 30s
                    this.tasksTimer = setInterval(() => {
                        this.fetchTasks();
                    }, 30000);
                }
            }

            stopAutoRefresh() {
                if (this.statsTimer) clearInterval(this.statsTimer);
                if (this.tasksTimer) clearInterval(this.tasksTimer);
                this.statsTimer = null;
                this.tasksTimer = null;
            }


            toggleAutoRefresh() {
                this.autoRefresh = !this.autoRefresh;
                const text = document.getElementById('autoRefreshText');

                if (this.autoRefresh) {
                    text.textContent = 'üîÑ Auto Refresh ON';
                    this.startAutoRefresh();
                } else {
                    text.textContent = '‚è∏Ô∏è Auto Refresh OFF';
                    this.stopAutoRefresh();
                }
            }

            clearEvents() {
                const container = document.getElementById('eventsContainer');
                container.innerHTML = '<div class="event-item queue_stats"><div class="event-time">Limpiado</div><div class="event-type">Sistema</div><div>Eventos limpiados</div></div>';
            }

            exportData() {
                const stats = {
                    timestamp: new Date().toISOString(),
                    workers: document.getElementById('workersGrid').innerHTML,
                    events: Array.from(document.getElementById('eventsContainer').children).map(el => el.textContent),
                    tasks: Array.from(document.getElementById('taskQueue').children).map(el => el.textContent)
                };

                const blob = new Blob([JSON.stringify(stats, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `queue-stats-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            destroy() {
                this.stopAutoRefresh();
                if (this.eventSource) {
                    this.eventSource.close();
                }
            }
        }

        // Funciones globales para los botones
        function toggleAutoRefresh() {
            autoRefreshEnabled = !autoRefreshEnabled;
            const text = document.getElementById('autoRefreshText');
            
            if (autoRefreshEnabled) {
                text.textContent = 'üîÑ Auto Refresh ON';
                startAutoRefresh();
            } else {
                text.textContent = '‚è∏Ô∏è Auto Refresh OFF';
                if (refreshInterval) clearInterval(refreshInterval);
            }
            
            console.log(`Auto refresh: ${autoRefreshEnabled ? 'ON' : 'OFF'}`);
        }

        function clearEvents() {
            const eventsContainer = document.getElementById('eventsContainer');
            if (eventsContainer) {
                eventsContainer.innerHTML = '<p>üìù Log de eventos limpiado</p>';
            }
            console.log('üóëÔ∏è Eventos limpiados');
        }

        function exportData() {
            const data = {
                timestamp: new Date().toISOString(),
                system_status: 'exported',
                note: 'Datos exportados desde dashboard'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dashboard_export_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('üì§ Datos exportados');
        }

        // Funci√≥n para limpiar todas las tareas de todas las colas
        async function clearAllTasks() {
            if (!confirm('‚ö†Ô∏è ¬øEst√°s seguro de que quieres eliminar TODAS las tareas de TODAS las colas?\n\nEsta acci√≥n no se puede deshacer.')) {
                return;
            }
            
            updateEventLog('Iniciando limpieza completa de tareas...', 'sistema');
            
            try {
                const response = await fetch('/queue/cleanup/all-tasks', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateEventLog(`‚úÖ Todas las tareas eliminadas: ${result.message || 'Operaci√≥n completada'}`, 'success');
                    
                    // Refrescar datos
                    setTimeout(() => {
                        refreshData();
                    }, 1000);
                } else {
                    const error = await response.json();
                    updateEventLog(`‚ùå Error limpiando tareas: ${error.detail || 'Error desconocido'}`, 'error');
                }
                
            } catch (error) {
                updateEventLog(`‚ùå Error de conexi√≥n: ${error.message}`, 'error');
            }
        }

        // Funci√≥n para escalar una cola espec√≠fica
        async function scaleQueue() {
            const queueSelect = document.getElementById('queueSelect');
            const workerCount = document.getElementById('workerCount');
            
            const selectedQueue = queueSelect.value;
            const workers = parseInt(workerCount.value);
            
            if (!selectedQueue) {
                alert('‚ö†Ô∏è Selecciona una cola primero');
                return;
            }
            
            if (!workers || workers < 0 || workers > 10) {
                alert('‚ö†Ô∏è N√∫mero de workers debe estar entre 0 y 10');
                return;
            }
            
            try {
                const params = new URLSearchParams({
                    queue_name: selectedQueue,
                    target_workers: workers.toString()
                });
                
                const response = await fetch(`/queue/workers/scale-by-name?${params}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    alert(`‚úÖ Cola '${selectedQueue}' escalada a ${workers} workers`);
                    updateEventLog(`Cola '${selectedQueue}' escalada a ${workers} workers`, 'success');
                    refreshData();
                } else {
                    alert(`‚ùå Error escalando: ${result.detail || result.message || 'Error desconocido'}`);
                    updateEventLog(`Error escalando cola: ${result.detail || result.message}`, 'error');
                }
                
            } catch (error) {
                alert(`‚ùå Error de conexi√≥n: ${error.message}`);
            }
        }

        // === NUEVAS FUNCIONES PARA EL CONTROL AVANZADO ===
        // === FUNCIONES PARA CREACI√ìN MASIVA DE COLAS ===
        function showBulkCreateModal() {
            document.getElementById('bulkCreateModal').style.display = 'block';
        }

        function closeBulkCreateModal() {
            document.getElementById('bulkCreateModal').style.display = 'none';
        }

        async function createBulkQueues() {
            const count = parseInt(document.getElementById('bulkQueueCount').value);
            const workers = parseInt(document.getElementById('bulkWorkerCount').value);
            const prefix = document.getElementById('bulkQueuePrefix').value || 'cola_';

            if (!count || count < 1 || count > 50) {
                alert('‚ö†Ô∏è Especifica un n√∫mero v√°lido de colas (1-50)');
                return;
            }

            if (!workers || workers < 1 || workers > 1000) {
                alert('‚ö†Ô∏è Especifica un n√∫mero v√°lido de workers (1-1000)');
                return;
            }

            updateEventLog(`üöÄ Iniciando creaci√≥n de ${count} colas especializadas con ${workers} workers cada una...`, 'sistema');
            closeBulkCreateModal();

            try {
                // Usar el endpoint correcto de bulk-create que asigna rangos especializados autom√°ticamente
                const response = await fetch(`/queue/queues/bulk-create?count=${count}&workers_per_queue=${workers}&prefix=${prefix}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        updateEventLog(`‚úÖ Creaci√≥n exitosa: ${result.created_count} colas especializadas`, 'success');
                        
                        // Mostrar detalles de las colas creadas
                        result.created_queues.forEach((queue, index) => {
                            updateEventLog(`   üìä ${queue.name}: Prioridad ${queue.priority_range[0]}-${queue.priority_range[1]} (${queue.max_workers} workers)`, 'success');
                        });
                        
                        if (result.failed_count > 0) {
                            updateEventLog(`‚ö†Ô∏è ${result.failed_count} colas fallaron`, 'warning');
                        }
                    } else {
                        updateEventLog(`‚ùå Error en creaci√≥n masiva: ${result.message}`, 'error');
                    }
                } else {
                    const error = await response.json();
                    let errorMsg = error.detail || 'Error desconocido';
                    
                    // Mostrar mensaje m√°s amigable para l√≠mites de rangos
                    if (errorMsg.includes('rangos de prioridad')) {
                        updateEventLog(`‚ö†Ô∏è L√≠mite alcanzado: ${errorMsg}`, 'warning');
                    } else {
                        updateEventLog(`‚ùå Error: ${errorMsg}`, 'error');
                    }
                }
                
            } catch (error) {
                updateEventLog(`‚ùå Error de conexi√≥n: ${error.message}`, 'error');
            }
            
            // Refrescar datos despu√©s de un momento
            setTimeout(() => {
                refreshData();
            }, 3000);
        }

        // === FUNCIONES PARA ELIMINAR COLAS ===
        async function removeQueue(queueName) {
            if (!confirm(`‚ö†Ô∏è ¬øEst√°s seguro de que quieres eliminar la cola '${queueName}'?\n\nEsta acci√≥n no se puede deshacer.`)) {
                return;
            }
            
            updateEventLog(`üóëÔ∏è Eliminando cola '${queueName}'...`, 'sistema');
            
            try {
                // Primero obtener el ID din√°mico de la cola
                const queuesResponse = await fetch('/queue/queues/all');
                const queuesData = await queuesResponse.json();
                
                if (!queuesData.success) {
                    updateEventLog(`‚ùå Error obteniendo informaci√≥n de colas`, 'error');
                    return;
                }
                
                // Buscar el ID din√°mico por nombre
                let dynamicId = null;
                const dynamicQueues = queuesData.dynamic_queues || {};
                
                for (const [id, queueInfo] of Object.entries(dynamicQueues)) {
                    if (queueInfo.config && queueInfo.config.name === queueName) {
                        dynamicId = id;
                        break;
                    }
                }
                
                if (!dynamicId) {
                    updateEventLog(`‚ùå No se encontr√≥ el ID din√°mico para la cola '${queueName}'`, 'error');
                    return;
                }
                
                // Eliminar usando el ID din√°mico
                const response = await fetch(`/queue/queues/dynamic/${dynamicId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateEventLog(`‚úÖ Cola '${queueName}' eliminada exitosamente`, 'success');
                    
                    // Refrescar datos
                    setTimeout(() => {
                        refreshData();
                    }, 1000);
                } else {
                    const error = await response.json();
                    updateEventLog(`‚ùå Error eliminando cola '${queueName}': ${error.detail || 'Error desconocido'}`, 'error');
                }
                
            } catch (error) {
                updateEventLog(`‚ùå Error de conexi√≥n eliminando cola '${queueName}': ${error.message}`, 'error');
            }
        }

        async function clearAllQueues() {
            if (!confirm(`‚ö†Ô∏è ¬øEst√°s seguro de que quieres eliminar TODAS las colas din√°micas?\n\nEsto eliminar√° todas las colas excepto la autom√°tica.\nEsta acci√≥n no se puede deshacer.`)) {
                return;
            }
            
            updateEventLog(`üóëÔ∏è Eliminando todas las colas din√°micas...`, 'sistema');
            
            try {
                // Obtener todas las colas
                const statusResponse = await fetch('/queue/queues/all');
                const statusData = await statusResponse.json();
                
                if (!statusData.success) {
                    updateEventLog(`‚ùå Error obteniendo lista de colas`, 'error');
                    return;
                }
                
                const dynamicQueues = statusData.dynamic_queues || {};
                const queueIds = Object.keys(dynamicQueues);
                
                if (queueIds.length === 0) {
                    updateEventLog(`‚ÑπÔ∏è No hay colas din√°micas para eliminar`, 'info');
                    return;
                }
                
                let removed = 0;
                let failed = 0;
                
                for (const queueId of queueIds) {
                    try {
                        const response = await fetch(`/queue/queues/dynamic/${queueId}`, {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        
                        if (response.ok) {
                            removed++;
                            updateEventLog(`‚úÖ Cola '${queueId}' eliminada`, 'success');
                        } else {
                            failed++;
                            updateEventLog(`‚ùå Error eliminando '${queueId}'`, 'error');
                        }
                        
                        // Peque√±a pausa entre eliminaciones
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        failed++;
                        updateEventLog(`‚ùå Error eliminando '${queueId}': ${error.message}`, 'error');
                    }
                }
                
                updateEventLog(`üéâ Eliminaci√≥n masiva completada: ${removed} eliminadas, ${failed} fallidas`, removed > failed ? 'success' : 'error');
                
                // Refrescar datos
                setTimeout(() => {
                    refreshData();
                }, 2000);
                
            } catch (error) {
                updateEventLog(`‚ùå Error durante eliminaci√≥n masiva: ${error.message}`, 'error');
            }
        }

        // Variables globales para el dashboard
        let autoRefreshEnabled = true;
        let refreshInterval;

        // Inicializar cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            initializeDashboard();
        });

        // Inicializaci√≥n del dashboard
        function initializeDashboard() {
            console.log('üöÄ Dashboard iniciado');
            
            // Limpiar contenedor de eventos y agregar mensaje inicial
            const eventsContainer = document.getElementById('eventsContainer');
            if (eventsContainer) {
                eventsContainer.innerHTML = '';
            }
            
            updateEventLog('Dashboard iniciado correctamente', 'sistema');
            refreshData(); // Cargar datos iniciales
            startAutoRefresh(); // Iniciar refresco autom√°tico
        }

        // Iniciar refresco autom√°tico
        function startAutoRefresh() {
            if (refreshInterval) clearInterval(refreshInterval);
            if (autoRefreshEnabled) {
                refreshInterval = setInterval(refreshData, 3000); // Cada 3 segundos
            }
        }

        // Funci√≥n principal para refrescar datos
        async function refreshData() {
            try {
                await Promise.all([
                    updateSystemStatus(),
                    updateQueuesList(),
                    updateRecentTasks(),
                    updatePriorityStats()
                ]);
                
                updateConnectionStatus(true);
                console.log('‚úÖ Datos actualizados correctamente');
            } catch (error) {
                console.error('‚ùå Error actualizando datos:', error);
                updateConnectionStatus(false);
            }
        }

        // Actualizar estado del sistema
        async function updateSystemStatus() {
            try {
                const response = await fetch('/queue/status');
                const data = await response.json();
                
                // Actualizar m√©tricas principales con valores correctos
                const systemTypeElement = document.getElementById('systemType');
                if (systemTypeElement) {
                    systemTypeElement.textContent = 'Sistema Din√°mico';
                }
                
                const totalWorkersElement = document.getElementById('totalWorkers');
                if (totalWorkersElement) {
                    totalWorkersElement.textContent = data.total_workers || 0;
                }
                
                const totalQueuesElement = document.getElementById('totalQueues');
                if (totalQueuesElement) {
                    totalQueuesElement.textContent = data.total_queues || 0;
                }
                
                const pendingTasksElement = document.getElementById('pendingTasks');
                if (pendingTasksElement) {
                    pendingTasksElement.textContent = data.task_counts?.pending || 0;
                }
                
                const processingTasksElement = document.getElementById('processingTasks');
                if (processingTasksElement) {
                    processingTasksElement.textContent = data.task_counts?.processing || 0;
                }
                
                const completedTasksElement = document.getElementById('completedTasks');
                if (completedTasksElement) {
                    completedTasksElement.textContent = data.task_counts?.completed || 0;
                }
                
                const failedTasksElement = document.getElementById('failedTasks');
                if (failedTasksElement) {
                    failedTasksElement.textContent = data.task_counts?.failed || 0;
                }
                
                const scalingEventsElement = document.getElementById('scalingEvents');
                if (scalingEventsElement) {
                    scalingEventsElement.textContent = data.dynamic_scaling_events || 0;
                }
                
            } catch (error) {
                console.error('Error actualizando estado del sistema:', error);
            }
        }

        // Actualizar lista de colas
        async function updateQueuesList() {
            try {
                const response = await fetch('/queue/status');
                const data = await response.json();
                
                const queuesContainer = document.getElementById('queuesContainer');
                if (queuesContainer && data.queue_details) {
                    queuesContainer.innerHTML = '';
                    
                    Object.entries(data.queue_details).forEach(([queueId, queueInfo]) => {
                        const queueCard = createQueueCard(queueId, queueInfo);
                        queuesContainer.appendChild(queueCard);
                    });
                    
                    // Si no hay colas, mostrar mensaje
                    if (Object.keys(data.queue_details).length === 0) {
                        queuesContainer.innerHTML = `
                            <div class="queue-placeholder">
                                <p>üì≠ No hay colas activas</p>
                                <small>Crea una nueva cola para comenzar</small>
                            </div>
                        `;
                    }
                }
                
                // Actualizar selector de colas
                updateQueueSelector(data.queue_details || {});
                

                
            } catch (error) {
                console.error('Error actualizando lista de colas:', error);
            }
        }



        // Crear card de cola
        function createQueueCard(queueId, queueInfo) {
            const card = document.createElement('div');
            card.className = 'queue-card';
            
            // Determinar si es la cola autom√°tica (no se puede eliminar)
            const isAutoDefault = queueId === 'auto_default';
            
            card.innerHTML = `
                <div class="queue-header">
                    <h4>${queueId} ${isAutoDefault ? 'ü§ñ' : ''}</h4>
                    <span class="queue-status active">Activa</span>
                </div>
                <div class="queue-stats">
                    <div class="stat">
                        <span class="stat-value">${queueInfo.active_workers || 0}</span>
                        <span class="stat-label">Workers</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value">${queueInfo.pending_tasks || 0}</span>
                        <span class="stat-label">Pendientes</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value">${queueInfo.processed_tasks || 0}</span>
                        <span class="stat-label">Procesadas</span>
                    </div>
                </div>
                <div class="queue-priority">
                    Prioridad: ${queueInfo.priority_range[0]}-${queueInfo.priority_range[1]} | Max: ${queueInfo.max_workers} workers
                </div>
                <div class="queue-activity">
                    <small>√öltima actividad: ${new Date(queueInfo.last_activity).toLocaleTimeString()}</small>
                </div>
                ${!isAutoDefault ? `
                    <button class="btn danger" style="width:100%; margin-top:10px; font-size:0.8rem;" 
                            onclick="removeQueue('${queueId}')">
                        üóëÔ∏è Eliminar Cola
                    </button>
                ` : `
                    <div style="text-align: center; margin-top: 10px; font-size: 0.8rem; color: #666;">
                        <small>ü§ñ Cola autom√°tica del sistema</small>
                    </div>
                `}
            `;
            return card;
        }

        // Actualizar selector de colas
        function updateQueueSelector(queues) {
            const selector = document.getElementById('queueSelect');
            if (selector) {
                selector.innerHTML = '<option value="">Seleccionar cola...</option>';
                Object.entries(queues).forEach(([queueId, queueInfo]) => {
                    const option = document.createElement('option');
                    option.value = queueId;
                    option.textContent = `${queueId} (${queueInfo.active_workers}/${queueInfo.max_workers} workers)`;
                    selector.appendChild(option);
                });
            }
        }

        // Actualizar tareas recientes
        async function updateRecentTasks() {
            const taskQueue = document.getElementById('taskQueue');
            if (!taskQueue) return;
            
            try {
                // Usar el endpoint de status que sabemos que funciona
                const response = await fetch('/queue/status');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                taskQueue.innerHTML = '';
                
                // Mostrar informaci√≥n basada en los stats del sistema
                const stats = data.task_counts || {};
                const totalTasks = stats.pending + stats.processing + stats.completed + stats.failed;
                
                if (totalTasks > 0) {
                    taskQueue.innerHTML = `
                        <div class="task-item completed">
                            <div>
                                <strong>Tareas Completadas</strong><br>
                                <small>Total procesadas: ${stats.completed || 0}</small>
                            </div>
                            <span class="task-priority">‚úÖ</span>
                        </div>
                        <div class="task-item processing">
                            <div>
                                <strong>Tareas en Proceso</strong><br>
                                <small>Actualmente procesando: ${stats.processing || 0}</small>
                            </div>
                            <span class="task-priority">‚ö°</span>
                        </div>
                        <div class="task-item pending">
                            <div>
                                <strong>Tareas Pendientes</strong><br>
                                <small>En cola: ${stats.pending || 0}</small>
                            </div>
                            <span class="task-priority">‚è≥</span>
                        </div>
                    `;
                } else {
                    // Sin tareas
                    taskQueue.innerHTML = `
                        <div class="task-item">
                            <div>
                                <strong>Sin tareas recientes</strong><br>
                                <small>Las tareas aparecer√°n aqu√≠ cuando se procesen</small>
                            </div>
                            <span class="task-priority">üì≠</span>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error cargando tareas:', error);
                taskQueue.innerHTML = `
                    <div class="task-item">
                        <div>
                            <strong>Sistema activo</strong><br>
                            <small>Monitoreando tareas en tiempo real</small>
                        </div>
                        <span class="task-priority">üîÑ</span>
                    </div>
                `;
            }
        }

        // Actualizar estad√≠sticas por prioridad
        async function updatePriorityStats() {
            const priorityStats = document.getElementById('priorityStats');
            if (!priorityStats) return;
            
            try {
                const response = await fetch('/queue/status');
                if (!response.ok) throw new Error('No se pudo obtener estad√≠sticas');
                
                const data = await response.json();
                const priorityCounts = data.priority_counts || {};
                
                priorityStats.innerHTML = '';
                
                if (Object.keys(priorityCounts).length === 0) {
                    // Generar datos simulados basados en las colas activas
                    const queueDetails = data.queue_details || {};
                    let hasData = false;
                    
                    Object.values(queueDetails).forEach(queue => {
                        if (queue.pending_tasks > 0) {
                            hasData = true;
                        }
                    });
                    
                    if (hasData) {
                        // Mostrar distribuci√≥n simulada
                        priorityStats.innerHTML = `
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee;">
                                <span>Prioridad 1-2:</span>
                                <strong>Alta</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee;">
                                <span>Prioridad 3-5:</span>
                                <strong>Media</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                                <span>Prioridad 6-10:</span>
                                <strong>Baja</strong>
                            </div>
                        `;
                    } else {
                        priorityStats.innerHTML = `
                            <div style="text-align: center; color: #666; padding: 20px;">
                                üìä Sistema optimizado<br>
                                <small>Distribuci√≥n equilibrada de tareas</small>
                            </div>
                        `;
                    }
                } else {
                    // Mostrar datos reales
                    Object.entries(priorityCounts).forEach(([priority, count]) => {
                        const statItem = document.createElement('div');
                        statItem.style.cssText = 'display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #eee;';
                        statItem.innerHTML = `
                            <span>Prioridad ${priority}:</span>
                            <strong style="color: #667eea;">${count} tareas</strong>
                        `;
                        priorityStats.appendChild(statItem);
                    });
                }
                
            } catch (error) {
                console.error('Error actualizando estad√≠sticas por prioridad:', error);
                priorityStats.innerHTML = `
                    <div style="text-align: center; color: #999; padding: 20px;">
                        üìä Estad√≠sticas no disponibles
                    </div>
                `;
            }
        }

        // Actualizar log de eventos
        function updateEventLog(message, type = 'info') {
            const eventsContainer = document.getElementById('eventsContainer');
            if (eventsContainer) {
                const eventItem = document.createElement('div');
                eventItem.className = `event-item ${type}`;
                eventItem.innerHTML = `
                    <div class="event-content">
                        <strong>${type.toUpperCase()}</strong><br>
                        <span>${message}</span>
                    </div>
                    <small class="event-time">${new Date().toLocaleTimeString()}</small>
                `;
                
                // Agregar al inicio
                eventsContainer.insertBefore(eventItem, eventsContainer.firstChild);
                
                // Mantener solo los √∫ltimos 10 eventos
                while (eventsContainer.children.length > 10) {
                    eventsContainer.removeChild(eventsContainer.lastChild);
                }
            }
        }

        // Actualizar estado de conexi√≥n
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (status) {
                status.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
                status.textContent = connected ? '‚úÖ Conectado' : '‚ùå Desconectado';
                
                // Log de eventos de conexi√≥n
                if (!connected) {
                    updateEventLog('Conexi√≥n perdida con el servidor', 'error');
                }
            }
        }

        // Manejo de errores globales
        window.addEventListener('error', (event) => {
            console.error('Error global:', event.error);
        });

        // Funci√≥n para simular datos (√∫til para testing)
        function simulateData() {
            const mockEvents = [
                { event_type: 'task_created', task_type: 'create_estudiante', timestamp: new Date().toISOString() },
                { event_type: 'task_started', worker_id: 'worker_1', timestamp: new Date().toISOString() },
                { event_type: 'task_completed', timestamp: new Date().toISOString() }
            ];

            mockEvents.forEach((event, index) => {
                setTimeout(() => dashboard.addEvent(event), index * 1000);
            });
        }

        // Agregar funci√≥n para testing en consola
        console.log('üéØ Dashboard cargado. Usa simulateData() para probar eventos.');
    </script>
</body>

</html>